<!doctype html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>hello phaser!</title>
        <script src="//cdn.jsdelivr.net/phaser/2.5.0/phaser.min.js"></script>
    </head>
    <body>

    <script type="text/javascript">

    window.onload = function() {

        // This example uses the Phaser 2.2.2 framework

        // Copyright Â© 2014 John Watson
        // Licensed under the terms of the MIT License
        var GameState = function(game) {
            this.MAX_RABBITS = 10; // number of rabbits
            //this.MAX_RABBITS = 10; // number of rabbits
            this.MAX_CARROTS = 35; // number of carrots
            this.STARTING_RABBITS = 10; // number of rabbits
            this.STARTING_RABBITS = 10; // number of rabbits
            this.FRAMES_PER_DAY =  60;
            this.DAYS_PER_YEAR = 16; 
            this.DAYS_PER_SEASON = 4;
            this.SEASONS = ["SPRING", "SUMMER", "FALL", "WINTER"]; 
        };

        // Load images and sounds
        GameState.prototype.preload = function() {
            this.game.load.image('rocket', 'assets/gfx/rocket.png');
            
            this.game.load.spritesheet('explosion', 'assets/gfx/explosion.png', 128, 128);
        };

        // Setup the example
        GameState.prototype.create = function() {
            // Set stage background to something sky colored
            this.game.stage.backgroundColor = "0x489030";
            console.log("here");
            //this.field = Field(game, 640, 480);
            // Create a group to hold the rabbit
            this.rabbitGroup = this.game.add.group();

            // Create a group for explosions
            this.explosionGroup = this.game.add.group();

             // Create a group to old the carrots
            this.carrotGroup = this.game.add.group();

            // Create a group to hold the dens
            this.rabbitDenGroup = this.game.add.group();

            this.frameCount = 0;
            this.dayCount = 0;
            this.output = "dayCount:" + this.dayCount;
            this.text = game.add.text(20, game.world.height-20, this.output, { font: "12px Arial", fill: "#000000", align: "center" });

            // Simulate a pointer click/tap input at the center of the stage
            // when the example begins running.
            this.game.input.activePointer.x = this.game.width/2;
            this.game.input.activePointer.y = this.game.height/2 - 100;

        };

        // The update() method is called every frame
        GameState.prototype.update = function() {
            this.frameCount++;
            //this.text = game.add.text(game.world.centerX, game.world.height-20, this.output, { font: "12px Arial", fill: "#000000", align: "center" });
            if (this.frameCount == this.FRAMES_PER_DAY) {
                this.frameCount = 0;
                this.dayCount++;
                this.output = "dayCount:" + this.dayCount;
                this.text.destroy();
                this.text = game.add.text(20, game.world.height-20, this.output, { font: "12px Arial", fill: "#000000", align: "center" });
            }

            if(this.dayCount) {

            }

            // If there are fewer than MAX_RABBITS, launch a new one
            if (this.rabbitGroup.countLiving() < this.MAX_RABBITS) {
                // Set the launch point to a random location below the bottom edge
                // of the stage
                //this.launchRabbit(this.game.rnd.integerInRange(50, this.game.width-50),
                //    this.game.height + 50);
                this.launchRabbit(this.game.world.centerX, this.game.world.centerY);
            }

           //// If any rabbit is within a certain distance of the mouse pointer, blow it up
           //this.rabbitGroup.forEachAlive(function(m) {
           //    var distance = this.game.math.distance(m.x, m.y,
           //        this.game.input.activePointer.x, this.game.input.activePointer.y);
           //    if (distance < 50) {
           //        m.kill();
           //        this.getExplosion(m.x, m.y);
           //    }
           //}, this);
        };

        // Try to get a rabbit from the rabbitGroup
        // If a rabbit isn't available, create a new one and add it to the group.
        GameState.prototype.launchRabbit = function(x, y) {
            // // Get the first dead rabbit from the rabbitGroup
            var rabbit = this.rabbitGroup.getFirstDead();

            // If there aren't any available, create a new one
            if (rabbit === null) {
                rabbit = new Rabbit(this.game);
                this.rabbitGroup.add(rabbit);
            }

            // Revive the rabbit (set it's alive property to true)
            // You can also define a onRevived event handler in your explosion objects
            // to do stuff when they are revived.
            rabbit.revive();

            // Move the rabbit to the given coordinates
            rabbit.x = x;
            rabbit.y = y;

            return rabbit;
        };

        // Try to get a used explosion from the explosionGroup.
        // If an explosion isn't available, create a new one and add it to the group.
        // Setup new explosions so that they animate and kill themselves when the
        // animation is complete.
        GameState.prototype.getExplosion = function(x, y) {
            // Get the first dead explosion from the explosionGroup
            var explosion = this.explosionGroup.getFirstDead();

            // If there aren't any available, create a new one
            if (explosion === null) {
                explosion = this.game.add.sprite(0, 0, 'explosion');
                explosion.anchor.setTo(0.5, 0.5);

                // Add an animation for the explosion that kills the sprite when the
                // animation is complete
                var animation = explosion.animations.add('boom', [0,1,2,3], 60, false);
                animation.killOnComplete = true;

                // Add the explosion sprite to the group
                this.explosionGroup.add(explosion);
            }

            // Revive the explosion (set it's alive property to true)
            // You can also define a onRevived event handler in your explosion objects
            // to do stuff when they are revived.
            explosion.revive();

            // Move the explosion to the given coordinates
            explosion.x = x;
            explosion.y = y;

            // Set rotation of the explosion at random for a little variety
            explosion.angle = this.game.rnd.integerInRange(0, 360);

            // Play the animation
            explosion.animations.play('boom');

            // Return the explosion itself in case we want to do anything else with it
            return explosion;
        };

        var Field = function(game, width, height) {
            this.bmd = game.add.bitmapData(width, height);
            console.log(">>>>")
            var old_time = new Date();
            for(var i = 0; i < 100; i+=2) {
                for(var j = 0; j < 100; j+=2) {
                    if(Phaser.Utils.chanceRoll(70)) {
                        this.bmd.setPixel(i, j, 120, 144, 48, 255);
                        this.bmd.setPixel(i, j+1, 120, 144, 48, 255);
                        this.bmd.setPixel(i+1, j, 120, 144, 48, 255);
                        this.bmd.setPixel(i+1, j+1, 120, 144, 48, 255);
                    } else {
                        if(Phaser.Utils.chanceRoll(70)) {
                            this.bmd.setPixel(i, j, 72, 144, 48, 255);
                            this.bmd.setPixel(i+1, j, 72, 144, 48, 255);
                            this.bmd.setPixel(i, j+1, 72, 144, 48, 255);
                            this.bmd.setPixel(i+1, j+1, 72, 144, 48, 255);
                        } else {
                            this.bmd.setPixel(i, j, 144, 120, 48, 0);
                            this.bmd.setPixel(i+1, j, 144, 120, 48, 0);
                            this.bmd.setPixel(i, j+1, 144, 120, 48, 0);
                            this.bmd.setPixel(i+1, j+1, 144, 120, 48, 0);
                        }
                    }
                }
            }
            var new_time = new Date();
            console.log(new_time - old_time);
            //    console.log("here");
            //    for(var j = 0; j < height; i++) {
            //        this.bmd.setPixel(i, j, 120, 144, 48, 0);
            //            //this.bmd.setPixel(i, j, 120, 144, 48, 0);
            //        } else {
            //            if(Phaser.Utils.chanceRoll(70)) {
            //                //this.bmd.setPixel(i, j, 72, 144, 48, 0);
            //            } else {
            //                //this.bmd.setPixel(i, j, 144, 120, 48, 0);
            //            }
            //        }
            //    }
            //}
            game.add.sprite(0, 0, this.bmd);
        };

        // Rabbit constructor
        var Rabbit = function(game, x, y) {
            //Phaser.Sprite.call(this, game, x, y, 'rocket');
            Phaser.Graphics.call(this, game, x, y);
            this.graphics = game.add.graphics(0, 0);
            window.graphics = this.graphics;
                        
            //game.context.fillRect(x, y, 4, 4);
            // Set the pivot point for this sprite to the center
            this.anchor.setTo(0.5, 0.5);
            //this.tint = "0xFF0000";
            // Enable physics on the rabbit
            this.game.physics.enable(this, Phaser.Physics.ARCADE);

            // Define constants that affect motion
            this.SPEED = 7; // 5mph
            this.SPEED = 7*5; // 25mph
            this.TURN_RATE = 15; // turn rate in degrees/frame
            this.WOBBLE_LIMIT = 5; // degrees
            this.WOBBLE_SPEED = 250; // milliseconds
            this.AVOID_DISTANCE = 10; // pixels

            var colors = [
                "0x926239",
                "0x967327",
                "0x90594a",
                "0xa5684a",
                "0x5b3d24",
                "0xd3c0af",
                "0xc8b09c",
            ];
            var rand = Math.floor(Math.random() * colors.length);
            this.color = colors[rand];

            // Create a variable called wobble that tweens back and forth between
            // -this.WOBBLE_LIMIT and +this.WOBBLE_LIMIT forever
            this.wobble = this.WOBBLE_LIMIT;
            this.game.add.tween(this)
                .to(
                    { wobble: -this.WOBBLE_LIMIT },
                    this.WOBBLE_SPEED, Phaser.Easing.Sinusoidal.InOut, true, 0,
                    Number.POSITIVE_INFINITY, true
                );
        };

        Field.prototype = Object.create(Phaser.Sprite.prototype);
        Field.prototype.constructor = Field;
        // Rabbits are a type of Phaser.Sprite
        Rabbit.prototype = Object.create(Phaser.Graphics.prototype);//Object.create(Phaser.Sprite.prototype);
        Rabbit.prototype.constructor = Rabbit;
        Rabbit.prototype.update = function() {
            // Calculate the angle from the rabbit to the mouse cursor game.input.x
            // and game.input.y are the mouse position; substitute with whatever
            // target coordinates you need.
            var targetAngle = this.game.math.angleBetween(
                this.x, this.y,
                this.game.input.activePointer.x, this.game.input.activePointer.y
            );

            // Add our "wobble" factor to the targetAngle to make the rabbit wobble
            // Remember that this.wobble is tweening (above)
            targetAngle += this.game.math.degToRad(this.wobble);


            // Make each rabbit steer away from other rabbits.
            // Each rabbit knows the group that it belongs to (rabbitGroup).
            // It can calculate its distance from all other rabbits in the group and
            // steer away from any that are too close. This avoidance behavior prevents
            // all of the rabbits from bunching up too tightly and following the
            // same track.
            var avoidAngle = 0;
            this.parent.forEachAlive(function(m) {
                // Don't calculate anything if the other rabbit is me
                if (this == m) return;

                // Already found an avoidAngle so skip the rest
                if (avoidAngle !== 0) return;

                // Calculate the distance between me and the other rabbit
                var distance = this.game.math.distance(this.x, this.y, m.x, m.y);

                // If the rabbit is too close...
                if (distance < this.AVOID_DISTANCE) {
                    // Chose an avoidance angle of 90 or -90 (in radians)
                    avoidAngle = Math.PI/2; // zig
                    //if (this.game.math.chanceRoll(50)) avoidAngle *= -1; // zag
                    if (Phaser.Utils.chanceRoll(50)) avoidAngle *= -1; // zag
                }
            }, this);

            // Add the avoidance angle to steer clear of other rabbits
            targetAngle += avoidAngle;

            // Gradually (this.TURN_RATE) aim the rabbit towards the target angle
            if (this.rotation !== targetAngle) {
                // Calculate difference between the current angle and targetAngle
                var delta = targetAngle - this.rotation;

                // Keep it in range from -180 to 180 to make the most efficient turns.
                if (delta > Math.PI) delta -= Math.PI * 2;
                if (delta < -Math.PI) delta += Math.PI * 2;

                if (delta > 0) {
                    // Turn clockwise
                    this.angle += this.TURN_RATE;
                } else {
                    // Turn counter-clockwise
                    this.angle -= this.TURN_RATE;
                }

                // Just set angle to target angle if they are close
                if (Math.abs(delta) < this.game.math.degToRad(this.TURN_RATE)) {
                    this.rotation = targetAngle;
                }
            }

            // Calculate velocity vector based on this.rotation and this.SPEED
            this.body.velocity.x = Math.cos(this.rotation) * this.SPEED;
            this.body.velocity.y = Math.sin(this.rotation) * this.SPEED;
            
             // draw a rectangle
            this.graphics.clear();
            

            graphics.lineStyle(1, this.color, 1);
            graphics.drawRect(this.x, this.y, 1, 1);
        };

        var game = new Phaser.Game(640, 480, Phaser.AUTO, 'game');
        game.state.add('game', GameState, true);
        
    };

    </script>

    </body>
</html>